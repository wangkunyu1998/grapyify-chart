"use strict";(self.webpackChunkgraphify_chart=self.webpackChunkgraphify_chart||[]).push([["11"],{3527:function(e,n,t){t.r(n),t.d(n,{default:()=>o});var r=t(5893),c=t(65),s=t(7294),i=t(7448);let l=function(){let e=(0,s.useRef)(null);return(0,s.useEffect)(()=>{let n=new i.Stage(e.current,734,300),t=new i.Rect(n,{x:0,y:0}),r=new i.Rect(n,{x:50,y:50,fillStyle:"green"}),c=new i.Rect(n,{x:100,y:100,fillStyle:"pink"}),s=new i.Group(n,{draggable:!0});s.appendChild(r,c),n.appendChild(t,s)},[]),(0,r.jsx)("div",{ref:e,style:{height:300}})},d=function(){let e=(0,s.useRef)(null);return(0,s.useEffect)(()=>{let n=new i.Stage(e.current,700,300),t=new i.Rect(n,{x:0,y:0,zIndex:2}),r=new i.Circle(n,{x:100,y:100,fillStyle:"green",zIndex:1});r.addEventListener("click",()=>{console.log("click"),r.setAttr({zIndex:1===r.zIndex?3:1})}),t.addEventListener("click",()=>console.log("rect")),n.appendChild(t,r)},[]),(0,r.jsx)("div",{ref:e,style:{height:200}})};var a=t(92);function p(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",div:"div",pre:"pre"},(0,c.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"节点",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#节点",children:"#"}),"节点"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"graphify-chart"}),"中的图表、图形、图形组或其他组合组都是虚拟节点，类似于 HTML 页面中的 DOM 节点。"]}),"\n",(0,r.jsxs)(n.p,{children:["和DOM不同，在",(0,r.jsx)(n.code,{children:"graphify-chart"}),"中我们采用了扁平的方式管理节点，因此在大多数情况下，所有的节点都是兄弟节点的关系。在性能表现上，这种方式优势非常大。"]}),"\n",(0,r.jsxs)(n.div,{className:"rspress-directive warning",children:[(0,r.jsx)(n.div,{className:"rspress-directive-title",children:"WARNING"}),(0,r.jsx)(n.div,{className:"rspress-directive-content",children:(0,r.jsx)(n.p,{children:"\n除Stage Group外，其他所有节点都不支持appendChild方法"})})]}),"\n",(0,r.jsx)(n.p,{children:"因此，我们在使用时，也不需要考虑那么复杂的布局规则，可以直接按照绝对定位的思路来布局。"}),"\n",(0,r.jsx)(n.p,{children:"当然，开发者可以基于自己的基础组件扩展布局方式。"}),"\n",(0,r.jsx)(n.p,{children:"除此之外，在某些部分复杂的场景，我们引入了 Group 的概念来管理组件。但是一定要注意的是，Group 本身不是一个元素节点，他只是负责给元素分组方便统一管理。例如统一拖拽。"}),"\n",(0,r.jsx)(n.p,{children:"示例如下："}),"\n",(0,r.jsxs)(a.Z,{isMobile:"false",demoId:"_design_node_1",children:[(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",meta:"preview",children:"import {useEffect,useState,useRef} from 'react';\nimport {Stage,Rect,Group} from 'graphify-chart';\nfunction App() {\n  const chartRef = useRef(null);\n  useEffect(() => {\n    const stage = new Stage(chartRef.current,734,300);\n    const rect1 = new Rect(stage,{x:0,y:0});\n    const rect2 = new Rect(stage,{x:50,y:50,fillStyle:'green'});\n    const rect3 = new Rect(stage,{x:100,y:100,fillStyle:'pink'});\n    const group = new Group(stage,{draggable:true})\n    group.appendChild(rect2,rect3)\n    stage.appendChild(rect1,group)\n  },[])\n  \n  return ( <div ref={chartRef} style={{height:300}} ></div>)\n}\nexport default App;\n"})}),(0,r.jsx)(l,{})]}),"\n",(0,r.jsx)(n.p,{children:"Group 组件不影响组件的布局。不参与组件的渲染。"}),"\n",(0,r.jsx)(n.p,{children:"节点之间，我们设计了 zIndex 属性来管理层级关系。我们可以直接简单的通过修改 zIndex 的值，来修改元素之间的遮挡关系。由于所有的可视节点都是扁平的，因此节点的关系就是直接比较大小即可。"}),"\n",(0,r.jsxs)(a.Z,{isMobile:"false",demoId:"_design_node_2",children:[(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",meta:"preview",children:"import {useEffect,useState,useRef} from 'react';\nimport {Stage,Rect,Circle} from 'graphify-chart';\nfunction App() {\n  const chartRef = useRef(null);\n  useEffect(() => {\n    const stage = new Stage(chartRef.current,700,300);\n    const rect = new Rect(stage,{x:0,y:0,zIndex:2});\n    const circle = new Circle(stage,{x:100,y:100,fillStyle:'green',zIndex:1});\n    circle.addEventListener('click',() => {\n      console.log('click')\n      circle.setAttr({zIndex:circle.zIndex === 1 ? 3 : 1})\n    } )\n    rect.addEventListener('click',() =>console.log('rect'))\n    stage.appendChild(rect,circle)\n  },[])\n  return ( <div ref={chartRef} style={{height:200}} ></div>)\n}\nexport default App;\n"})}),(0,r.jsx)(d,{})]})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,r.jsx)(n,Object.assign({},e,{children:(0,r.jsx)(p,e)})):p(e)}let o=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["design%2Fnode.mdx"]={toc:[],title:"节点",headingTitle:"节点",frontmatter:{}}}}]);